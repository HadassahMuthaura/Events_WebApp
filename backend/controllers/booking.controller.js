import { validationResult } from 'express-validator';
import { supabase } from '../config/supabase.js';
import QRCode from 'qrcode';
import { sendBookingConfirmation } from '../services/email.service.js';

const generateReferenceNumber = () => {
  return 'BK' + Date.now() + Math.random().toString(36).substr(2, 9).toUpperCase();
};

export const createBooking = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { event_id, number_of_tickets } = req.body;

    // Check for scheduling conflicts
    const { data: eventToBook } = await supabase
      .from('events')
      .select('date, title')
      .eq('id', event_id)
      .single();

    if (eventToBook) {
      const { data: existingBookings } = await supabase
        .from('bookings')
        .select('id, events!inner(date, title)')
        .eq('user_id', req.user.id)
        .in('status', ['confirmed', 'pending']);

      if (existingBookings && existingBookings.length > 0) {
        const eventDate = new Date(eventToBook.date);
        for (const booking of existingBookings) {
          const existingDate = new Date(booking.events.date);
          const timeDiff = Math.abs(eventDate - existingDate) / (1000 * 60 * 60);
          
          // Check if events are within 3 hours of each other
          if (timeDiff < 3) {
            return res.status(409).json({
              error: `Scheduling conflict: You have a booking for "${booking.events.title}" at ${existingDate.toLocaleString()}. Events are less than 3 hours apart.`,
              conflict: true
            });
          }
        }
      }
    }

    // Check if event exists and has available tickets
    const { data: event, error: eventError } = await supabase
      .from('events')
      .select('*')
      .eq('id', event_id)
      .single();

    if (eventError || !event) {
      return res.status(404).json({ error: 'Event not found' });
    }

    if (event.available_tickets < number_of_tickets) {
      return res.status(400).json({ error: 'Not enough tickets available' });
    }

    // Calculate total amount
    const total_amount = event.price * number_of_tickets;

    // Generate QR code (reference will be generated by trigger)
    const qrData = JSON.stringify({
      event: event_id,
      user: req.user.id,
      tickets: number_of_tickets
    });
    const qr_code = await QRCode.toDataURL(qrData);

    // Create booking (booking_reference will be auto-generated by trigger)
    const { data: booking, error } = await supabase
      .from('bookings')
      .insert([
        {
          user_id: req.user.id,
          event_id,
          number_of_tickets,
          total_amount,
          qr_code,
          status: 'confirmed'
        }
      ])
      .select()
      .single();

    if (error) throw error;

    // Update available tickets
    await supabase
      .from('events')
      .update({ available_tickets: event.available_tickets - number_of_tickets })
      .eq('id', event_id);

    // Fetch user info for email
    const { data: user } = await supabase
      .from('users')
      .select('*')
      .eq('id', req.user.id)
      .single();

    // Send confirmation email (async, don't block response)
    if (user) {
      sendBookingConfirmation(
        { ...booking, reference_number: booking.booking_reference, tickets_count: number_of_tickets },
        user,
        event
      ).catch(err => console.error('Email send failed:', err));
    }

    res.status(201).json({
      message: 'Booking created successfully',
      booking
    });
  } catch (error) {
    console.error('Create booking error:', error);
    res.status(500).json({ error: 'Failed to create booking' });
  }
};

export const getUserBookings = async (req, res) => {
  try {
    const { data: bookings, error } = await supabase
      .from('bookings')
      .select(`
        *,
        events(title, date, location, category, image_url)
      `)
      .eq('user_id', req.user.id)
      .order('created_at', { ascending: false });

    if (error) throw error;

    res.json({ bookings });
  } catch (error) {
    console.error('Get user bookings error:', error);
    res.status(500).json({ error: 'Failed to fetch bookings' });
  }
};

export const getBookingById = async (req, res) => {
  try {
    const { id } = req.params;

    const { data: booking, error } = await supabase
      .from('bookings')
      .select(`
        *,
        events(title, date, location, category, image_url),
        users(full_name, email)
      `)
      .eq('id', id)
      .single();

    if (error || !booking) {
      return res.status(404).json({ error: 'Booking not found' });
    }

    // Check if user owns this booking or is admin
    if (booking.user_id !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Access denied' });
    }

    res.json({ booking });
  } catch (error) {
    console.error('Get booking error:', error);
    res.status(500).json({ error: 'Failed to fetch booking' });
  }
};

export const cancelBooking = async (req, res) => {
  try {
    const { id } = req.params;

    // Get booking details
    const { data: booking, error: bookingError } = await supabase
      .from('bookings')
      .select('*, events(*)')
      .eq('id', id)
      .single();

    if (bookingError || !booking) {
      return res.status(404).json({ error: 'Booking not found' });
    }

    // Check if user owns this booking
    if (booking.user_id !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Access denied' });
    }

    if (booking.status === 'cancelled') {
      return res.status(400).json({ error: 'Booking already cancelled' });
    }

    // Update booking status
    const { error: updateError } = await supabase
      .from('bookings')
      .update({ status: 'cancelled' })
      .eq('id', id);

    if (updateError) throw updateError;

    // Restore available tickets
    await supabase
      .from('events')
      .update({
        available_tickets: booking.events.available_tickets + booking.number_of_tickets
      })
      .eq('id', booking.event_id);

    res.json({ message: 'Booking cancelled successfully' });
  } catch (error) {
    console.error('Cancel booking error:', error);
    res.status(500).json({ error: 'Failed to cancel booking' });
  }
};

// Check-in attendee (organizers only)
export const checkInAttendee = async (req, res) => {
  try {
    const { id } = req.params;

    // Get booking and verify organizer
    const { data: booking, error: fetchError } = await supabase
      .from('bookings')
      .select('*, events(organizer_id)')
      .eq('id', id)
      .single();

    if (fetchError || !booking) {
      return res.status(404).json({ error: 'Booking not found' });
    }

    if (booking.events.organizer_id !== req.user.id) {
      return res.status(403).json({ error: 'Only event organizers can check in attendees' });
    }

    if (booking.status !== 'confirmed') {
      return res.status(400).json({ error: 'Only confirmed bookings can be checked in' });
    }

    // Mark as checked in
    const { data: updated, error: updateError } = await supabase
      .from('bookings')
      .update({ 
        checked_in_at: new Date().toISOString(),
        status: 'attended'
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) throw updateError;

    res.json({
      message: 'Attendee checked in successfully',
      booking: updated
    });
  } catch (error) {
    console.error('Check-in error:', error);
    res.status(500).json({ error: 'Failed to check in attendee' });
  }
};

// Verify QR code and check in
export const verifyAndCheckIn = async (req, res) => {
  try {
    const { qr_data } = req.body;

    if (!qr_data) {
      return res.status(400).json({ error: 'QR code data is required' });
    }

    let qrInfo;
    try {
      qrInfo = JSON.parse(qr_data);
    } catch {
      return res.status(400).json({ error: 'Invalid QR code format' });
    }

    // Find booking by reference number
    const { data: booking, error: fetchError } = await supabase
      .from('bookings')
      .select('*, events(organizer_id, title), users(full_name, email)')
      .eq('reference_number', qrInfo.ref)
      .single();

    if (fetchError || !booking) {
      return res.status(404).json({ error: 'Booking not found' });
    }

    // Verify event organizer
    if (booking.events.organizer_id !== req.user.id) {
      return res.status(403).json({ error: 'Access denied' });
    }

    if (booking.checked_in_at) {
      return res.status(200).json({
        message: 'Already checked in',
        booking,
        already_checked_in: true,
        checked_in_at: booking.checked_in_at
      });
    }

    // Check in
    const { data: updated, error: updateError } = await supabase
      .from('bookings')
      .update({ 
        checked_in_at: new Date().toISOString(),
        status: 'attended'
      })
      .eq('id', booking.id)
      .select('*, users(full_name, email)')
      .single();

    if (updateError) throw updateError;

    res.json({
      message: 'Check-in successful',
      booking: updated,
      attendee: updated.users
    });
  } catch (error) {
    console.error('QR verification error:', error);
    res.status(500).json({ error: 'Failed to verify and check in' });
  }
};

export const getAllBookings = async (req, res) => {
  try {
    const { data: bookings, error } = await supabase
      .from('bookings')
      .select(`
        *,
        events(title, date, location),
        users(full_name, email)
      `)
      .order('created_at', { ascending: false });

    if (error) throw error;

    res.json({ bookings });
  } catch (error) {
    console.error('Get all bookings error:', error);
    res.status(500).json({ error: 'Failed to fetch bookings' });
  }
};
